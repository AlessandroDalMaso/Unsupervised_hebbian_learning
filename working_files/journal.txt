20/10/2020
	Ho cominciato a tenere questo diario come suggeritomi dal professor
	Giampieri. Oggi ho eliminato il salvare le matrici - non mi stupisco che
	open.io mi occupasse la maggior parte del tempo! Adesso devo implementare
	la lazy implementation.
21/10/2020
	Ho riscritto le docstrings, ma ancora devo implementare l'approcio lazy.
22/10/2020
	Ho implementato l'approcio lazy. Risultato: un errore mai visto prima che
	non riesco a risolvere. Devo cercare di risolverlo prima di parlare con
	Giampieri.
23/10/2020
    Ho risolto, stava lavorando con 784 neuroni hidden. Ho finalmente aggiunto
    l'activation function. il tempo di esecuzione è su minuto ad immagine con
    cinque neuroni. Ho provato a modificare il parametro Dfun di odeint, ma
    peggiora la situazione.
24/10/2020
    Giorno di riposo.
25/10/2020
    Da guardare: trasformata di Randon.
26/10/2020
    Ho passato un giorno a capire un errore banale, ma nel frattempo ho
    imparato le funzioni lambda e i breakpoint di spyder. Ora posso finalmente
    vedere i vari metodi di integrazione.
27/10/2020
	I metodi di integrazione sono tutti più lenti di odeint, ma forse posso
	implementare solve_ivp in modo vettorizzato?
28/10/2020
	Niente da fare. Cosa posso tentare ora?
29/10/2020
30/10/2020
	Forse ho trovato: fare l'evoluzione solo per gli hidden neurons che
	effettivamente cambiano
31/10/2020
	riposo
01/11/2020
	Sto implementando, molto a rilento.
02/11/2020
04/11/2020
	Ho fatto uno schemino che mi rende il tutto più chiaro e sto implementando.
10/11/2020
	Mi sono dimenticato di aggiornare questo diario. Devo ancora prendere
	l'abitudine.
	Ho un problema: plasticity_rule deve conoscere gli indici degli
	hidden_neurons da cambiare, e anche uno slide di weight_matrix, quindi devo
	usare un ciclo for. idee:
	-zip (MOLTO PI§ VELOCE)
	-vectorize spiegato dal prof
14/11/2020
	Mi sono dimenticato di nuovo di aggiornare questo diario. Ho messo una sveglia per ricordarmi.
	Il programma adesso funziona così: rank_finder mi manda una tupla di 2 array 1d che mi danno l'indice k su ciascuna riga i,
	e li passo a plasticity_rule_vectorized, che poi passa tutto a plasticity_rule con 1d data e 1d weights, e returna 1d.s
15/11/2020
16/11/2020
	Sto cercando di testare plsticity_rule_vectorized.
23/11/2020
	Dopo aver riscritto l'intero programma finalmente sembra funzionare. Spero davvero che stavolta sia la volta buona...
27/11/2020
	È davvero la volta buona sembra, ma domani devo scegliere se laurearsi a marzo o luglio.
30/11/2020
	luglio sia. mi sono appena accorto che fittando ogni volta sovrascrivevo weight_matrix. andiamo bene...
01/11/2020
	*marzo.